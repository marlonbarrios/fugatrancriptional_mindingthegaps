import './style.css';
import OpenAI from 'openai';

const openAIKey = import.meta.env.VITE_OPENAI_KEY;

let openai;
let isLoading = false;
let isGenerating = false;
// Application states
let appState = 'ANIMATION'; // Start directly in animation mode
let homeAnimationTime = 0;

// Automatic generation timing
let lastGenerationTime = 0;
const AUTO_GENERATION_INTERVAL = 60000; // 60 seconds = 1 minute

// Reading mode state
let readingMode = false;

// Loading state variables already declared at top

// Manual language selection tracking
let manualLanguageSelection = false;

// changeLanguageInterface function is defined later with full color handling

// Function for manual language selection (called by interface)
function selectLanguageManually(language) {
  console.log(`MANUAL LANGUAGE SELECTION: Switching from ${currentLanguage} to ${language}`);
  currentLanguage = language;
  manualLanguageSelection = true;
  
  // Update interface immediately
  changeLanguageInterface(language);
  
  // Reset generation timer and trigger immediate generation in the selected language
  lastGenerationTime = Date.now();
  
  // Trigger generation immediately in the selected language
  console.log(`IMMEDIATE GENERATION: Starting generation in ${language}`);
  generateNewText();
}

let scrollingText = "press SPACE for new language & text • press L for new language • press E for topology exposition • automatic generation every minute • flowing consciousness across languages"; 
let textPositions = []; // Remove fixed size initialization
const SCROLL_SPEED = 3;
const SPACING = 200;
let fontSize;
// Default colors
const DEFAULT_COLORS = ['#5bc0eb', '#fde74c', '#9bc53d', '#e55934', '#fa7921', '#c44569', '#40407a', '#706fd3', '#f8b500', '#34ace0'];

// Language-specific color schemes
const LANGUAGE_COLOR_SCHEMES = {
  // European Languages - Cool blues and greens
  'English': ['#2c3e50', '#3498db', '#2980b9', '#1abc9c', '#16a085', '#27ae60', '#2ecc71', '#95a5a6', '#7f8c8d', '#34495e'],
  'French': ['#8e44ad', '#9b59b6', '#e74c3c', '#c0392b', '#d35400', '#e67e22', '#f39c12', '#f1c40f', '#2ecc71', '#27ae60'],
  'German': ['#2c3e50', '#34495e', '#7f8c8d', '#95a5a6', '#bdc3c7', '#ecf0f1', '#e74c3c', '#c0392b', '#f39c12', '#f1c40f'],
  'Spanish': ['#e74c3c', '#c0392b', '#d35400', '#e67e22', '#f39c12', '#f1c40f', '#27ae60', '#2ecc71', '#8e44ad', '#9b59b6'],
  'Italian': ['#27ae60', '#2ecc71', '#e74c3c', '#c0392b', '#f1c40f', '#f39c12', '#8e44ad', '#9b59b6', '#3498db', '#2980b9'],
  'Portuguese': ['#27ae60', '#2ecc71', '#f1c40f', '#f39c12', '#3498db', '#2980b9', '#e74c3c', '#c0392b', '#8e44ad', '#9b59b6'],
  'Russian': ['#e74c3c', '#c0392b', '#3498db', '#2980b9', '#ecf0f1', '#bdc3c7', '#f1c40f', '#f39c12', '#2c3e50', '#34495e'],
  'Dutch': ['#e67e22', '#d35400', '#3498db', '#2980b9', '#ecf0f1', '#bdc3c7', '#e74c3c', '#c0392b', '#27ae60', '#2ecc71'],
  'Polish': ['#ecf0f1', '#bdc3c7', '#e74c3c', '#c0392b', '#f1c40f', '#f39c12', '#3498db', '#2980b9', '#8e44ad', '#9b59b6'],
  'Swedish': ['#3498db', '#2980b9', '#f1c40f', '#f39c12', '#ecf0f1', '#bdc3c7', '#27ae60', '#2ecc71', '#8e44ad', '#9b59b6'],
  'Greek': ['#3498db', '#2980b9', '#ecf0f1', '#bdc3c7', '#27ae60', '#2ecc71', '#e74c3c', '#c0392b', '#f1c40f', '#f39c12'],
  
  // Asian Languages - Warm reds, golds, and earth tones
  'Chinese': ['#e74c3c', '#c0392b', '#f1c40f', '#f39c12', '#d35400', '#e67e22', '#8e44ad', '#9b59b6', '#2c3e50', '#34495e'],
  'Japanese': ['#e74c3c', '#c0392b', '#ecf0f1', '#bdc3c7', '#2c3e50', '#34495e', '#f1c40f', '#f39c12', '#8e44ad', '#9b59b6'],
  'Korean': ['#3498db', '#2980b9', '#e74c3c', '#c0392b', '#ecf0f1', '#bdc3c7', '#f1c40f', '#f39c12', '#27ae60', '#2ecc71'],
  'Vietnamese': ['#f1c40f', '#f39c12', '#e74c3c', '#c0392b', '#27ae60', '#2ecc71', '#3498db', '#2980b9', '#8e44ad', '#9b59b6'],
  'Thai': ['#f1c40f', '#f39c12', '#e74c3c', '#c0392b', '#8e44ad', '#9b59b6', '#27ae60', '#2ecc71', '#3498db', '#2980b9'],
  'Hindi': ['#e67e22', '#d35400', '#f1c40f', '#f39c12', '#27ae60', '#2ecc71', '#8e44ad', '#9b59b6', '#e74c3c', '#c0392b'],
  
  // Middle Eastern/Arabic - Desert and jewel tones
  'Arabic': ['#d35400', '#e67e22', '#f1c40f', '#f39c12', '#27ae60', '#2ecc71', '#8e44ad', '#9b59b6', '#2c3e50', '#34495e'],
  'Turkish': ['#e74c3c', '#c0392b', '#f1c40f', '#f39c12', '#ecf0f1', '#bdc3c7', '#27ae60', '#2ecc71', '#8e44ad', '#9b59b6'],
  'Hebrew': ['#3498db', '#2980b9', '#ecf0f1', '#bdc3c7', '#f1c40f', '#f39c12', '#8e44ad', '#9b59b6', '#2c3e50', '#34495e'],
  
  // African Languages - Earth tones and vibrant colors
  'Swahili': ['#27ae60', '#2ecc71', '#f1c40f', '#f39c12', '#e74c3c', '#c0392b', '#2c3e50', '#34495e', '#d35400', '#e67e22'],
  'Yoruba': ['#f1c40f', '#f39c12', '#27ae60', '#2ecc71', '#e74c3c', '#c0392b', '#8e44ad', '#9b59b6', '#d35400', '#e67e22'],
  'Zulu': ['#e74c3c', '#c0392b', '#f1c40f', '#f39c12', '#27ae60', '#2ecc71', '#2c3e50', '#34495e', '#d35400', '#e67e22'],
  'Amharic': ['#f1c40f', '#f39c12', '#e74c3c', '#c0392b', '#27ae60', '#2ecc71', '#2c3e50', '#34495e', '#8e44ad', '#9b59b6'],
  'Hausa': ['#27ae60', '#2ecc71', '#d35400', '#e67e22', '#f1c40f', '#f39c12', '#e74c3c', '#c0392b', '#2c3e50', '#34495e'],
  'Igbo': ['#27ae60', '#2ecc71', '#f1c40f', '#f39c12', '#e74c3c', '#c0392b', '#8e44ad', '#9b59b6', '#2c3e50', '#34495e'],
  'Xhosa': ['#e74c3c', '#c0392b', '#27ae60', '#2ecc71', '#f1c40f', '#f39c12', '#2c3e50', '#34495e', '#d35400', '#e67e22'],
  'Twi': ['#f1c40f', '#f39c12', '#27ae60', '#2ecc71', '#e74c3c', '#c0392b', '#d35400', '#e67e22', '#8e44ad', '#9b59b6'],
  'Somali': ['#3498db', '#2980b9', '#f1c40f', '#f39c12', '#27ae60', '#2ecc71', '#e74c3c', '#c0392b', '#2c3e50', '#34495e'],
  'Oromo': ['#27ae60', '#2ecc71', '#f1c40f', '#f39c12', '#d35400', '#e67e22', '#e74c3c', '#c0392b', '#2c3e50', '#34495e'],
  
  // Indigenous Languages - Nature and earth tones
  'Nahuatl': ['#d35400', '#e67e22', '#f1c40f', '#f39c12', '#27ae60', '#2ecc71', '#e74c3c', '#c0392b', '#2c3e50', '#34495e'],
  'Quechua': ['#8e44ad', '#9b59b6', '#f1c40f', '#f39c12', '#27ae60', '#2ecc71', '#d35400', '#e67e22', '#2c3e50', '#34495e'],
  'Maya': ['#27ae60', '#2ecc71', '#d35400', '#e67e22', '#f1c40f', '#f39c12', '#e74c3c', '#c0392b', '#8e44ad', '#9b59b6'],
  'Guarani': ['#27ae60', '#2ecc71', '#f1c40f', '#f39c12', '#3498db', '#2980b9', '#d35400', '#e67e22', '#e74c3c', '#c0392b'],
  'Navajo': ['#d35400', '#e67e22', '#f1c40f', '#f39c12', '#e74c3c', '#c0392b', '#2c3e50', '#34495e', '#8e44ad', '#9b59b6'],
  'Cherokee': ['#e74c3c', '#c0392b', '#f1c40f', '#f39c12', '#27ae60', '#2ecc71', '#2c3e50', '#34495e', '#d35400', '#e67e22'],
  'Maori': ['#27ae60', '#2ecc71', '#3498db', '#2980b9', '#f1c40f', '#f39c12', '#e74c3c', '#c0392b', '#2c3e50', '#34495e'],
  'Hawaiian': ['#3498db', '#2980b9', '#27ae60', '#2ecc71', '#f1c40f', '#f39c12', '#e74c3c', '#c0392b', '#d35400', '#e67e22'],
  'Ainu': ['#ecf0f1', '#bdc3c7', '#3498db', '#2980b9', '#2c3e50', '#34495e', '#27ae60', '#2ecc71', '#e74c3c', '#c0392b'],
  'Sami': ['#3498db', '#2980b9', '#ecf0f1', '#bdc3c7', '#27ae60', '#2ecc71', '#8e44ad', '#9b59b6', '#2c3e50', '#34495e']
};

const COLORS = DEFAULT_COLORS; // Current active colors
const BG_COLOR = '#000000'; // Keep black background
let loadingPhase = 0; // Track loading animation phase
let loadingAnimationType = 0; // Different animation types
let loadingStartTime = 0; // Track when loading started
let audioContext;
let isAudioInitialized = false;   
let activeOscillators = null;

// Add new constants and variables for dynamic movement
const SPEED_VARIATIONS = [0, 1, 2, 3, 4];
const DIRECTION_CHANGE_PROBABILITY = 0.01; // 1% chance per frame
const STOP_PROBABILITY = 0.005; // 0.5% chance to stop
const STOP_DURATION = 1000; // Stop for 1 second
let currentSpeeds = []; // Remove fixed size
let stopTimers = []; // Remove fixed size
let directions = []; // Remove fixed size

// Add sound control variables
const MINIMUM_SOUND_INTERVAL = 2000; // Minimum 2 seconds between sounds
let lastSoundTime = 0;

// Modify the color swap probability to be much lower
const COLOR_SWAP_PROBABILITY = 0.001; // 0.1% chance per frame to swap colors
const COLOR_SWAP_COOLDOWN = 3000; // Minimum 3 seconds between color swaps
let lastColorSwap = 0;

// Exposition/explanation system
let showExposition = false;
let expositionStartTime = 0;
const EXPOSITION_DURATION = 8000; // 8 seconds

// Creatures system - LLM Latent Space Entities
let creatures = [];
const MAX_CREATURES = 12;
const CREATURE_TYPES = {
  ATTENTION_HEAD: 0,      // Multi-headed attention mechanisms
  TOKEN_EMBEDDING: 1,     // High-dimensional token vectors
  GRADIENT_FLOW: 2,       // Backpropagation streams
  NEURAL_CLUSTER: 3,      // Connected neuron networks
  TRANSFORMER_LAYER: 4,   // Layer-by-layer processing
  SEMANTIC_MANIFOLD: 5    // Meaning space geometries
};

// Topological motion constants - simple geometric manifolds only
const TOPOLOGY_TYPES = {
  TORUS: 0,
  MOBIUS: 1
};

// Topological parameters for different text bands
let topologyStates = []; // Will store topology type for each band
let topologyPhases = []; // Phase parameters for each band
let flowField = []; // 2D flow field for organic motion
const FIELD_RESOLUTION = 20; // Resolution of the flow field grid

let currentColors = [...DEFAULT_COLORS]; // Make a copy of the original colors

// Exposition content for each topology type
const TOPOLOGY_EXPOSITIONS = {
  [TOPOLOGY_TYPES.TORUS]: {
    title: "Torus Topology",
    description: "A donut-shaped surface where text flows in circular patterns. The torus represents cyclical processes of thought and the continuity of consciousness across linguistic spaces.",
    mathematical: "Parametric equations: x = (R + r·cos(φ))·cos(θ), y = (R + r·cos(φ))·sin(θ)"
  },
  [TOPOLOGY_TYPES.MOBIUS]: {
    title: "Möbius Strip",
    description: "A non-orientable surface with only one side and one edge. Text appears to twist and flip, representing the fluid nature of meaning that can invert upon itself.",
    mathematical: "A twisted loop where traveling around once brings you to the 'other side'"
  }
};

// Function to get current topology exposition
function getCurrentTopologyExposition() {
  // Find the most common topology type currently active
  const topologyCounts = {};
  topologyStates.forEach(topology => {
    topologyCounts[topology] = (topologyCounts[topology] || 0) + 1;
  });
  
  let mostCommonTopology = TOPOLOGY_TYPES.TORUS;
  let maxCount = 0;
  
  for (const [topology, count] of Object.entries(topologyCounts)) {
    if (count > maxCount) {
      maxCount = count;
      mostCommonTopology = parseInt(topology);
    }
  }
  
  return TOPOLOGY_EXPOSITIONS[mostCommonTopology] || TOPOLOGY_EXPOSITIONS[TOPOLOGY_TYPES.TORUS];
}

// Topological transformation functions
function torusTransform(x, y, time, bandIndex) {
  const R = 200; // Major radius
  const r = 50;  // Minor radius
  const theta = (x / 100 + time * 0.5 + bandIndex * 0.3) % (Math.PI * 2);
  const phi = (y / 100 + time * 0.3) % (Math.PI * 2);
  
  return {
    x: (R + r * Math.cos(phi)) * Math.cos(theta),
    y: (R + r * Math.cos(phi)) * Math.sin(theta),
    scale: 1 + 0.3 * Math.sin(phi),
    rotation: theta * 0.1
  };
}

function mobiusTransform(x, y, time, bandIndex) {
  const radius = 150;
  const t = (x / 100 + time * 0.4 + bandIndex * 0.2) % (Math.PI * 2);
  const width = y / 10;
  
  const cosHalfT = Math.cos(t / 2);
  const sinHalfT = Math.sin(t / 2);
  const cosT = Math.cos(t);
  const sinT = Math.sin(t);
  
  return {
    x: (radius + width * cosHalfT) * cosT,
    y: (radius + width * cosHalfT) * sinT,
    scale: 1 + 0.2 * Math.abs(cosHalfT),
    rotation: t / 2
  };
}

function kleinTransform(x, y, time, bandIndex) {
  const u = (x / 80 + time * 0.3 + bandIndex * 0.25) % (Math.PI * 2);
  const v = (y / 80 + time * 0.2) % (Math.PI * 2);
  
  const cosU = Math.cos(u);
  const sinU = Math.sin(u);
  const cosV = Math.cos(v);
  const sinV = Math.sin(v);
  
  return {
    x: (2 + cosV * cosU - sinV * sinU) * cosU * 30,
    y: (2 + cosV * cosU - sinV * sinU) * sinU * 30,
    scale: 1 + 0.4 * Math.abs(cosV),
    rotation: u * 0.3 + v * 0.1
  };
}

function hyperbolicTransform(x, y, time, bandIndex) {
  const scale = 0.01;
  const u = x * scale + time * 0.2 + bandIndex * 0.15;
  const v = y * scale + time * 0.15;
  
  const sinh_u = Math.sinh(u);
  const cosh_u = Math.cosh(u);
  const cos_v = Math.cos(v);
  const sin_v = Math.sin(v);
  
  return {
    x: sinh_u * cos_v * 100,
    y: sinh_u * sin_v * 100,
    scale: 1 + 0.5 * Math.abs(cosh_u * 0.1),
    rotation: Math.atan2(sin_v, cos_v) * 0.2
  };
}

function sphericalTransform(x, y, time, bandIndex) {
  const radius = 200;
  const theta = (x / 100 + time * 0.4 + bandIndex * 0.2) % (Math.PI * 2);
  const phi = (y / 100 + time * 0.3) % Math.PI;
  
  const sinPhi = Math.sin(phi);
  
  return {
    x: radius * sinPhi * Math.cos(theta),
    y: radius * sinPhi * Math.sin(theta),
    scale: 1 + 0.3 * Math.cos(phi),
    rotation: theta * 0.1 + phi * 0.05
  };
}

function generateFlowField() {
  flowField = [];
  const time = Date.now() * 0.001;
  
  for (let x = 0; x < FIELD_RESOLUTION; x++) {
    flowField[x] = [];
    for (let y = 0; y < FIELD_RESOLUTION; y++) {
      const noise1 = Math.sin(x * 0.3 + time * 0.5) * Math.cos(y * 0.3 + time * 0.3);
      const noise2 = Math.cos(x * 0.2 + time * 0.7) * Math.sin(y * 0.4 + time * 0.4);
      const angle = (noise1 + noise2) * Math.PI;
      const magnitude = (Math.abs(noise1) + Math.abs(noise2)) * 0.5;
      
      flowField[x][y] = {
        angle: angle,
        magnitude: magnitude
      };
    }
  }
}

function flowFieldTransform(x, y, time, bandIndex) {
  if (flowField.length === 0) generateFlowField();
  
  const fieldX = Math.floor((x / window.innerWidth) * FIELD_RESOLUTION);
  const fieldY = Math.floor((y / window.innerHeight) * FIELD_RESOLUTION);
  
  const safeX = Math.max(0, Math.min(FIELD_RESOLUTION - 1, fieldX));
  const safeY = Math.max(0, Math.min(FIELD_RESOLUTION - 1, fieldY));
  
  const field = flowField[safeX][safeY];
  const displacement = field.magnitude * 50;
  
  return {
    x: x + Math.cos(field.angle) * displacement,
    y: y + Math.sin(field.angle) * displacement,
    scale: 1 + field.magnitude * 0.3,
    rotation: field.angle * 0.1
  };
}

// Interface translations - reflecting realistic AI knowledge levels
const INTERFACE_TRANSLATIONS = {
  // STRONG KNOWLEDGE - Full interface translation
  'English': {
    instruction: 'press space bar to start transcriptional fugue',
    activated: 'transcriptional fugue activated'
  },
  'Spanish': {
    instruction: 'presiona la barra espaciadora para iniciar fuga transcripcional',
    activated: 'fuga transcripcional activada'
  },
  'French': {
    instruction: 'appuyez sur la barre d\'espace pour commencer la fugue transcriptionnelle',
    activated: 'fugue transcriptionnelle activée'
  },
  'German': {
    instruction: 'drücken Sie die Leertaste um die transkriptionelle Fuge zu starten',
    activated: 'transkriptionelle Fuge aktiviert'
  },
  'Italian': {
    instruction: 'premi la barra spaziatrice per iniziare la fuga trascrizionale',
    activated: 'fuga trascrizionale attivata'
  },
  'Portuguese': {
    instruction: 'pressione a barra de espaço para iniciar a fuga transcricional',
    activated: 'fuga transcricional ativada'
  },
  'Russian': {
    instruction: 'нажмите пробел чтобы начать транскрипционную фугу',
    activated: 'транскрипционная фуга активирована'
  },
  'Chinese': {
    instruction: '按空格键开始转录赋格',
    activated: '转录赋格已激活'
  },
  'Japanese': {
    instruction: 'スペースキーを押して転写フーガを開始',
    activated: '転写フーガが有効になりました'
  },
  'Korean': {
    instruction: '스페이스바를 눌러 전사 푸가를 시작하세요',
    activated: '전사 푸가가 활성화되었습니다'
  },
  'Arabic': {
    instruction: 'اضغط مفتاح المسافة لبدء الفوجا النسخية',
    activated: 'تم تفعيل الفوجا النسخية'
  },
  'Hindi': {
    instruction: 'ट्रांसक्रिप्शनल फ्यूग शुरू करने के लिए स्पेस बार दबाएं',
    activated: 'ट्रांसक्रिप्शनल फ्यूग सक्रिय'
  },
  'Dutch': {
    instruction: 'druk op de spatiebalk om de transcriptionele fuga te starten',
    activated: 'transcriptionele fuga geactiveerd'
  },
  
  // MODERATE KNOWLEDGE - Basic translation with disclaimer
  'Polish': {
    instruction: 'naciśnij spację aby rozpocząć fugę transkrypcyjną (limited AI knowledge)',
    activated: 'fuga transkrypcyjna aktywowana (uncertain translation)'
  },
  'Swedish': {
    instruction: 'tryck mellanslag för att starta transkriptionell fuga (limited AI knowledge)',
    activated: 'transkriptionell fuga aktiverad (uncertain translation)'
  },
  'Hebrew': {
    instruction: 'לחץ רווח להתחלת פוגה תמליל (limited AI knowledge)',
    activated: 'פוגה תמליל הופעלה (uncertain translation)'
  },
  'Swahili': {
    instruction: 'bonyeza nafasi kuanza fugue ya nakala (limited AI knowledge)',
    activated: 'fugue ya nakala imeamilishwa (uncertain translation)'
  },
  
  // LIMITED KNOWLEDGE - Honest about limitations
  'Navajo': {
    instruction: 'press space bar to start transcriptional fugue (AI has very limited Navajo knowledge)',
    activated: 'exploring Navajo language with limited AI understanding'
  },
  'Cherokee': {
    instruction: 'press space bar to start transcriptional fugue (AI has very limited Cherokee knowledge)',
    activated: 'exploring Cherokee language with limited AI understanding'
  },
  'Maya': {
    instruction: 'press space bar to start transcriptional fugue (AI has very limited Maya knowledge)',
    activated: 'exploring Maya language with limited AI understanding'
  },
  'Ainu': {
    instruction: 'press space bar to start transcriptional fugue (AI has very limited Ainu knowledge)',
    activated: 'exploring Ainu language with limited AI understanding'
  },
  'Sami': {
    instruction: 'press space bar to start transcriptional fugue (AI has very limited Sami knowledge)',
    activated: 'exploring Sami language with limited AI understanding'
  },
  'Yoruba': {
    instruction: 'press space bar to start transcriptional fugue (AI has limited Yoruba knowledge)',
    activated: 'exploring Yoruba language with limited AI understanding'
  },
  'Zulu': {
    instruction: 'press space bar to start transcriptional fugue (AI has limited Zulu knowledge)',
    activated: 'exploring Zulu language with limited AI understanding'
  },
  'Quechua': {
    instruction: 'press space bar to start transcriptional fugue (AI has limited Quechua knowledge)',
    activated: 'exploring Quechua language with limited AI understanding'
  }
};

// Function to get interface text in current language
function getInterfaceText(key) {
  if (INTERFACE_TRANSLATIONS[currentLanguage] && INTERFACE_TRANSLATIONS[currentLanguage][key]) {
    return INTERFACE_TRANSLATIONS[currentLanguage][key];
  }
  // Fallback to English
  return INTERFACE_TRANSLATIONS['English'][key];
}

// Function to change interface based on language
function changeLanguageInterface(language) {
  currentLanguage = language;
  console.log('Changing interface for language:', language);
  
  // Update colors if language has specific scheme
  if (LANGUAGE_COLOR_SCHEMES[language]) {
    currentColors = [...LANGUAGE_COLOR_SCHEMES[language]];
    console.log('Applied color scheme for', language);
  } else {
    currentColors = [...DEFAULT_COLORS];
    console.log('Using default color scheme for', language);
  }
  
  // Update text colors to complement the new scheme
  const newTextColors = currentColors.map(color => {
    // Create contrasting text colors
    const r = parseInt(color.slice(1,3), 16);
    const g = parseInt(color.slice(3,5), 16);
    const b = parseInt(color.slice(5,7), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness > 128 ? '#000000' : '#ffffff';
  });
  
  // Store the new text colors
  textColors = newTextColors;
  
  // Update interface text to match the language
  if (!isLoading && !isGenerating) {
    scrollingText = getInterfaceText('instruction');
  }
}

// Manual generation state variables (isGenerating declared at top)

// Add after the other constants
const LANGUAGES = {
  'English': 'english',
  'Spanish': 'spanish',
  'French': 'french',
  'German': 'german',
  'Italian': 'italian',
  'Portuguese': 'portuguese',
  'Russian': 'russian',
  'Japanese': 'japanese',
  'Chinese': 'chinese',
  'Korean': 'korean',
  'Arabic': 'arabic',
  'Hindi': 'hindi',
  'Turkish': 'turkish',
  'Dutch': 'dutch',
  'Polish': 'polish',
  'Swedish': 'swedish',
  'Greek': 'greek',
  'Vietnamese': 'vietnamese',
  'Thai': 'thai',
  'Hebrew': 'hebrew',
  // African languages
  'Swahili': 'swahili',
  'Yoruba': 'yoruba',
  'Zulu': 'zulu',
  'Amharic': 'amharic',
  'Hausa': 'hausa',
  'Igbo': 'igbo',
  'Xhosa': 'xhosa',
  'Twi': 'twi',
  'Somali': 'somali',
  'Oromo': 'oromo',
  // Indigenous languages
  'Nahuatl': 'nahuatl',     // Aztec
  'Quechua': 'quechua',     // Inca
  'Maya': 'maya',           // Mayan
  'Guarani': 'guarani',     // Paraguay/South America
  'Navajo': 'navajo',       // North America
  'Cherokee': 'cherokee',   // North America
  'Maori': 'maori',         // New Zealand
  'Hawaiian': 'hawaiian',   // Hawaii
  'Ainu': 'ainu',           // Japan
  'Sami': 'sami'           // Nordic indigenous
};

// Comprehensive language information database
const LANGUAGE_INFO = {
  'English': {
    speakers: '1.5 billion',
    region: 'Global (originated in England)',
    countries: ['USA', 'UK', 'Canada', 'Australia', 'India', '+ 60 others'],
    colonization: 'Primary colonizing language - spread through British Empire',
    threats: 'Dominates and threatens many indigenous languages globally',
    family: 'Germanic (Indo-European)',
    script: 'Latin alphabet',
    status: 'Dominant global lingua franca'
  },
  'Spanish': {
    speakers: '500 million',
    region: 'Iberia, Latin America',
    countries: ['Spain', 'Mexico', 'Colombia', 'Argentina', '+ 18 others'],
    colonization: 'Colonial language - spread through Spanish conquest of Americas',
    threats: 'Replaced many indigenous languages in Americas',
    family: 'Romance (Indo-European)',
    script: 'Latin alphabet',
    status: 'Major world language'
  },
  'French': {
    speakers: '280 million',
    region: 'France, West/Central Africa, Canada',
    countries: ['France', 'Congo', 'Canada', 'Senegal', '+ 25 others'],
    colonization: 'Colonial language in Africa and Americas',
    threats: 'Declining in some former colonies, competing with English',
    family: 'Romance (Indo-European)',
    script: 'Latin alphabet',
    status: 'International language of diplomacy'
  },
  'German': {
    speakers: '100 million',
    region: 'Central Europe',
    countries: ['Germany', 'Austria', 'Switzerland', 'Luxembourg'],
    colonization: 'Limited colonial history in Africa (Namibia, Tanzania)',
    threats: 'Regional language, less global influence',
    family: 'Germanic (Indo-European)',
    script: 'Latin alphabet',
    status: 'Major European language'
  },
  'Chinese': {
    speakers: '1.4 billion',
    region: 'China, Taiwan, Singapore',
    countries: ['China', 'Taiwan', 'Singapore'],
    colonization: 'Victim of Western colonization, now expanding globally',
    threats: 'Suppresses minority languages in China',
    family: 'Sino-Tibetan',
    script: 'Chinese characters (Hanzi)',
    status: 'Most spoken native language'
  },
  'Japanese': {
    speakers: '125 million',
    region: 'Japan',
    countries: ['Japan'],
    colonization: 'Colonized Korea, Taiwan - imposed Japanese language',
    threats: 'Declining birth rate threatens speaker numbers',
    family: 'Japonic (isolate)',
    script: 'Hiragana, Katakana, Kanji',
    status: 'National language of Japan'
  },
  'Korean': {
    speakers: '77 million',
    region: 'Korean Peninsula',
    countries: ['South Korea', 'North Korea'],
    colonization: 'Suppressed under Japanese occupation (1910-1945)',
    threats: 'Political division affects language unity',
    family: 'Koreanic (isolate)',
    script: 'Hangul',
    status: 'National language, recovering from colonial trauma'
  },
  'Arabic': {
    speakers: '420 million',
    region: 'Middle East, North Africa',
    countries: ['Saudi Arabia', 'Egypt', 'Morocco', '+ 22 others'],
    colonization: 'Spread through Islamic conquest, later colonized by Europeans',
    threats: 'Dialectal fragmentation, Western cultural influence',
    family: 'Semitic (Afroasiatic)',
    script: 'Arabic script',
    status: 'Sacred language of Islam'
  },
  'Hindi': {
    speakers: '600 million',
    region: 'Northern India',
    countries: ['India'],
    colonization: 'Suppressed under British rule, now promoted by Indian state',
    threats: 'Language politics in India, English dominance in education',
    family: 'Indo-Aryan (Indo-European)',
    script: 'Devanagari',
    status: 'Official language of India'
  },
  'Swahili': {
    speakers: '200 million',
    region: 'East Africa',
    countries: ['Tanzania', 'Kenya', 'Uganda', 'Congo'],
    colonization: 'Used by colonial administration, survived colonial period',
    threats: 'Competing with English and local languages',
    family: 'Bantu (Niger-Congo)',
    script: 'Latin alphabet',
    status: 'Pan-African lingua franca'
  },
  'Yoruba': {
    speakers: '46 million',
    region: 'West Africa, diaspora',
    countries: ['Nigeria', 'Benin', 'Togo', 'Brazil (diaspora)'],
    colonization: 'Suppressed by British colonial education',
    threats: 'English dominance in Nigeria, urbanization',
    family: 'Volta-Niger (Niger-Congo)',
    script: 'Latin alphabet (since colonization)',
    status: 'Major African language, preserved in Afro-diaspora religions'
  },
  'Nahuatl': {
    speakers: '1.7 million',
    region: 'Central Mexico',
    countries: ['Mexico'],
    colonization: 'Nearly destroyed by Spanish conquest, forced conversion',
    threats: 'Spanish dominance, urbanization, cultural assimilation',
    family: 'Uto-Aztecan',
    script: 'Latin alphabet (formerly pictographic)',
    status: 'Indigenous language, struggling to survive'
  },
  'Quechua': {
    speakers: '8 million',
    region: 'Andes Mountains',
    countries: ['Peru', 'Bolivia', 'Ecuador'],
    colonization: 'Suppressed by Spanish, banned in education for centuries',
    threats: 'Spanish dominance, migration to cities',
    family: 'Quechuan',
    script: 'Latin alphabet',
    status: 'Indigenous language with constitutional recognition'
  },
  'Cherokee': {
    speakers: '2,000',
    region: 'Southeastern USA',
    countries: ['USA'],
    colonization: 'Devastated by forced removal, boarding schools, English-only policies',
    threats: 'Critically endangered, few fluent speakers remain',
    family: 'Iroquoian',
    script: 'Cherokee syllabary',
    status: 'Critically endangered, revitalization efforts ongoing'
  },
  'Maori': {
    speakers: '150,000',
    region: 'New Zealand',
    countries: ['New Zealand'],
    colonization: 'Suppressed by British colonization, beaten out of children',
    threats: 'English dominance, historical trauma',
    family: 'Polynesian (Austronesian)',
    script: 'Latin alphabet',
    status: 'Official language, undergoing revitalization'
  }
};

// Add more language info for remaining languages
Object.keys(LANGUAGES).forEach(lang => {
  if (!LANGUAGE_INFO[lang]) {
    LANGUAGE_INFO[lang] = {
      speakers: 'Data needed',
      region: 'Various',
      countries: ['Multiple'],
      colonization: 'Complex history',
      threats: 'Various challenges',
      family: 'To be documented',
      script: 'Various',
      status: 'Active language'
    };
  }
});

// Language clusters based on proximity and model fluency (only well-known languages)
const LANGUAGE_CATEGORIES = {
  romance: ['Spanish', 'French', 'Italian', 'Portuguese'],
  germanic: ['English', 'German', 'Dutch'], 
  slavic: ['Russian', 'Polish'],
  eastAsian: ['Chinese', 'Japanese', 'Korean'],
  semitic: ['Arabic', 'Hebrew'],
  other: ['Hindi', 'Swedish', 'Greek', 'Turkish', 'Vietnamese', 'Thai', 'Swahili']
};

const CATEGORY_NAMES = {
  all: 'All Languages (21)',
  romance: 'Romance (4)',
  germanic: 'Germanic (3)',
  slavic: 'Slavic (2)',
  eastAsian: 'East Asian (3)',
  semitic: 'Semitic (2)',
  other: 'Other (7)'
};

// Extended language list including indigenous and less common languages
const SIMPLE_LANGUAGES = [
  // Well-supported languages
  'English', 'Spanish', 'French', 'German', 'Italian', 'Portuguese', 
  'Russian', 'Chinese', 'Japanese', 'Arabic', 'Hindi', 'Korean',
  
  // Indigenous and less common languages
  'Quechua', 'Nahuatl', 'Maya', 'Cherokee', 'Navajo', 'Guaraní',
  'Euskera', 'Catalán', 'Galego', 'Swahili', 'Yoruba', 'Amharic',
  'Telugu', 'Tamil', 'Bengali', 'Urdu', 'Thai', 'Vietnamese',
  'Indonesian', 'Tagalog', 'Maori', 'Hawaiian', 'Inuktitut', 'Sami'
];

// Languages that are well-supported by the model
const WELL_SUPPORTED_LANGUAGES = [
  'English', 'Spanish', 'French', 'German', 'Italian', 'Portuguese', 
  'Russian', 'Chinese', 'Japanese', 'Arabic', 'Hindi', 'Korean'
];

let currentLanguage = 'English'; // Start with English as base language

// Language menu state
let languageMenuOpen = false;

// Simple function to get languages (no categories)
function getLanguagesForMenu() {
  return SIMPLE_LANGUAGES;
}

// Function to get linguistically proximate language (simplified)
function getProximateLanguage(currentLang) {
  const languages = getLanguagesForMenu();
  const currentIndex = languages.indexOf(currentLang);
  
  if (currentIndex === -1) {
    // If current language not in list, return first language
    return languages[0];
  }
  
  // Return next language in the list (cycle back to start if at end)
  const nextIndex = (currentIndex + 1) % languages.length;
  return languages[nextIndex];
}

// LLM Latent Space Creature class
class LatentSpaceCreature {
  constructor(type, x, y) {
    this.type = type;
    this.x = x;
    this.y = y;
    this.vx = (Math.random() - 0.5) * 1;
    this.vy = (Math.random() - 0.5) * 1;
    this.age = 0;
    this.lifespan = 600 + Math.random() * 1200; // 10-30 seconds at 60fps
    this.size = 15 + Math.random() * 25;
    this.opacity = 0;
    this.phase = Math.random() * Math.PI * 2;
    this.activationLevel = 0;
    this.dimensions = 512 + Math.random() * 1536; // Embedding dimensions
    this.attentionWeights = [];
    this.neuralConnections = [];
    
    // Generate complex colors based on embedding space
    const hue = (this.dimensions / 2048) * 360;
    this.color = {
      r: Math.sin(hue * Math.PI / 180) * 127 + 128,
      g: Math.sin((hue + 120) * Math.PI / 180) * 127 + 128,
      b: Math.sin((hue + 240) * Math.PI / 180) * 127 + 128,
      a: 180
    };
    
    // Type-specific LLM properties
    switch (type) {
      case CREATURE_TYPES.ATTENTION_HEAD:
        this.numHeads = 8 + Math.floor(Math.random() * 8); // 8-16 heads
        this.heads = [];
        for (let i = 0; i < this.numHeads; i++) {
          this.heads.push({
            x: x + Math.cos(i * Math.PI * 2 / this.numHeads) * 30,
            y: y + Math.sin(i * Math.PI * 2 / this.numHeads) * 30,
            attention: Math.random(),
            queryVector: Math.random() * 2 - 1,
            keyVector: Math.random() * 2 - 1,
            valueVector: Math.random() * 2 - 1
          });
        }
        this.selfAttention = true;
        break;
        
      case CREATURE_TYPES.TOKEN_EMBEDDING:
        this.tokenId = Math.floor(Math.random() * 50000); // Vocab size
        this.embedding = [];
        for (let i = 0; i < 128; i++) { // Simplified embedding vector
          this.embedding.push(Math.random() * 2 - 1);
        }
        this.positionalEncoding = Math.random() * Math.PI * 2;
        this.semanticDensity = Math.random();
        break;
        
      case CREATURE_TYPES.GRADIENT_FLOW:
        this.gradientMagnitude = Math.random() * 0.01;
        this.flowVectors = [];
        for (let i = 0; i < 20; i++) {
          this.flowVectors.push({
            x: x + (Math.random() - 0.5) * 100,
            y: y + (Math.random() - 0.5) * 100,
            gradient: Math.random() * 2 - 1,
            velocity: Math.random() * 0.5
          });
        }
        this.backpropDirection = Math.random() * Math.PI * 2;
        break;
        
      case CREATURE_TYPES.NEURAL_CLUSTER:
        this.neurons = [];
        this.connections = [];
        const numNeurons = 12 + Math.floor(Math.random() * 8);
        for (let i = 0; i < numNeurons; i++) {
          this.neurons.push({
            x: x + (Math.random() - 0.5) * 60,
            y: y + (Math.random() - 0.5) * 60,
            activation: Math.random(),
            bias: Math.random() * 2 - 1,
            weights: []
          });
        }
        // Create connections between neurons
        for (let i = 0; i < numNeurons; i++) {
          for (let j = i + 1; j < numNeurons; j++) {
            if (Math.random() < 0.3) { // 30% connection probability
              this.connections.push({
                from: i,
                to: j,
                weight: Math.random() * 2 - 1,
                strength: Math.random()
              });
            }
          }
        }
        break;
        
      case CREATURE_TYPES.TRANSFORMER_LAYER:
        this.layerDepth = Math.floor(Math.random() * 24) + 1; // 1-24 layers
        this.hiddenSize = 768 + Math.floor(Math.random() * 1280); // 768-2048
        this.feedForwardSize = this.hiddenSize * 4;
        this.layerNorm = { mean: 0, variance: 1 };
        this.residualConnections = [];
        this.mlpLayers = [];
        for (let i = 0; i < 3; i++) {
          this.mlpLayers.push({
            weights: Math.random() * 2 - 1,
            activations: Math.random(),
            dropout: 0.1
          });
        }
        break;
        
      case CREATURE_TYPES.SEMANTIC_MANIFOLD:
        this.manifoldDimension = 512 + Math.floor(Math.random() * 1536);
        this.conceptVectors = [];
        this.semanticClusters = [];
        for (let i = 0; i < 8; i++) {
          this.conceptVectors.push({
            x: x + Math.cos(i * Math.PI / 4) * (20 + Math.random() * 40),
            y: y + Math.sin(i * Math.PI / 4) * (20 + Math.random() * 40),
            semanticWeight: Math.random(),
            cosineDistance: Math.random(),
            cluster: Math.floor(Math.random() * 3)
          });
        }
        this.latentSpace = {
          curvature: Math.random() * 2 - 1,
          topology: Math.floor(Math.random() * 3),
          dimensionality: this.manifoldDimension
        };
        break;
    }
  }
  
  update(p) {
    this.age++;
    
    // Sophisticated fade based on neural activation
    const activationFade = Math.sin(this.age * 0.02) * 0.3 + 0.7;
    if (this.age < 120) {
      this.opacity = (this.age / 120) * activationFade;
    } else if (this.age > this.lifespan - 120) {
      this.opacity = ((this.lifespan - this.age) / 120) * activationFade;
    } else {
      this.opacity = activationFade;
    }
    
    // Neural network-inspired movement patterns
    this.activationLevel = Math.sin(this.age * 0.01 + this.phase) * 0.5 + 0.5;
    
    // Movement influenced by high-dimensional space navigation
    const embeddingInfluence = Math.sin(this.dimensions * 0.001 + this.age * 0.005);
    this.vx += embeddingInfluence * 0.02;
    this.vy += Math.cos(this.dimensions * 0.001 + this.age * 0.005) * 0.02;
    
    // Damping based on computational complexity
    const complexity = this.dimensions / 2048;
    this.vx *= (0.95 + complexity * 0.04);
    this.vy *= (0.95 + complexity * 0.04);
    
    // Attraction to information-dense regions (text bands)
    if (typeof BAND_HEIGHT !== 'undefined' && BAND_HEIGHT > 0) {
      const informationDensity = Math.sin(this.x * 0.01) * Math.cos(this.y * 0.01);
      const bandY = (Math.floor(this.y / BAND_HEIGHT) + 0.5) * BAND_HEIGHT;
      this.vy += (bandY - this.y) * 0.0005 * (1 + informationDensity);
    }
    
    this.x += this.vx;
    this.y += this.vy;
    
    // Toroidal topology (wrap around like latent space)
    if (this.x < -100) this.x = p.width + 100;
    if (this.x > p.width + 100) this.x = -100;
    if (this.y < -100) this.y = p.height + 100;
    if (this.y > p.height + 100) this.y = -100;
    
    this.phase += 0.03 + this.activationLevel * 0.02;
    
    // Type-specific neural updates
    this.updateNeuralDynamics(p);
  }
  
  updateNeuralDynamics(p) {
    switch (this.type) {
      case CREATURE_TYPES.ATTENTION_HEAD:
        // Update multi-head attention patterns
        for (let head of this.heads) {
          head.attention = Math.max(0, Math.sin(this.age * 0.02 + head.queryVector) * 0.5 + 0.5);
          const attentionRadius = 20 + head.attention * 15;
          head.x = this.x + Math.cos(head.keyVector + this.phase) * attentionRadius;
          head.y = this.y + Math.sin(head.keyVector + this.phase) * attentionRadius;
          // Query-Key-Value attention mechanism simulation
          head.queryVector += (head.attention - 0.5) * 0.01;
          head.keyVector += Math.sin(this.age * 0.005) * 0.02;
        }
        break;
        
      case CREATURE_TYPES.TOKEN_EMBEDDING:
        // High-dimensional embedding space dynamics
        this.positionalEncoding += 0.01;
        this.semanticDensity = Math.sin(this.age * 0.003 + this.tokenId * 0.0001) * 0.5 + 0.5;
        // Simulate embedding vector updates
        for (let i = 0; i < this.embedding.length; i++) {
          this.embedding[i] += (Math.random() - 0.5) * 0.001; // Gradient updates
          this.embedding[i] = Math.max(-1, Math.min(1, this.embedding[i])); // Clamp
        }
        break;
        
      case CREATURE_TYPES.GRADIENT_FLOW:
        // Backpropagation flow simulation
        this.gradientMagnitude *= 0.999; // Gradient decay
        this.backpropDirection += Math.sin(this.age * 0.01) * 0.05;
        for (let vector of this.flowVectors) {
          vector.x += Math.cos(this.backpropDirection) * vector.velocity;
          vector.y += Math.sin(this.backpropDirection) * vector.velocity;
          vector.gradient *= 0.995; // Vanishing gradients
          vector.velocity = this.gradientMagnitude * 10;
        }
        break;
        
      case CREATURE_TYPES.NEURAL_CLUSTER:
        // Neural network activation propagation
        for (let neuron of this.neurons) {
          neuron.activation = Math.max(0, neuron.activation + neuron.bias * 0.01); // ReLU
          neuron.activation *= 0.99; // Decay
        }
        // Update connections with Hebbian learning
        for (let conn of this.connections) {
          const fromNeuron = this.neurons[conn.from];
          const toNeuron = this.neurons[conn.to];
          conn.weight += fromNeuron.activation * toNeuron.activation * 0.001;
          conn.weight = Math.max(-2, Math.min(2, conn.weight)); // Weight clipping
          conn.strength = Math.abs(conn.weight);
        }
        break;
        
      case CREATURE_TYPES.TRANSFORMER_LAYER:
        // Layer normalization and MLP updates
        this.layerNorm.mean = Math.sin(this.age * 0.005) * 0.1;
        this.layerNorm.variance = 0.8 + Math.cos(this.age * 0.003) * 0.2;
        for (let layer of this.mlpLayers) {
          layer.activations = Math.max(0, layer.activations + layer.weights * 0.01); // GELU approximation
          layer.weights += (Math.random() - 0.5) * 0.0001; // Weight updates
        }
        break;
        
      case CREATURE_TYPES.SEMANTIC_MANIFOLD:
        // Semantic space geometry updates
        this.latentSpace.curvature += Math.sin(this.age * 0.002) * 0.001;
        for (let concept of this.conceptVectors) {
          // Update concept positions in semantic space
          const semanticForce = this.latentSpace.curvature * concept.semanticWeight;
          concept.x += Math.cos(concept.cosineDistance + this.phase) * semanticForce;
          concept.y += Math.sin(concept.cosineDistance + this.phase) * semanticForce;
          concept.cosineDistance += 0.005;
          concept.semanticWeight = Math.sin(this.age * 0.001 + concept.cluster) * 0.5 + 0.5;
        }
        break;
    }
  }
  
  draw(p) {
    p.push();
    
    // Neural activation-based color intensity
    const activationIntensity = this.activationLevel * this.opacity * 150;
    const baseColor = p.color(this.color.r, this.color.g, this.color.b, activationIntensity);
    
    switch (this.type) {
      case CREATURE_TYPES.ATTENTION_HEAD:
        this.drawAttentionHead(p, baseColor);
        break;
      case CREATURE_TYPES.TOKEN_EMBEDDING:
        this.drawTokenEmbedding(p, baseColor);
        break;
      case CREATURE_TYPES.GRADIENT_FLOW:
        this.drawGradientFlow(p, baseColor);
        break;
      case CREATURE_TYPES.NEURAL_CLUSTER:
        this.drawNeuralCluster(p, baseColor);
        break;
      case CREATURE_TYPES.TRANSFORMER_LAYER:
        this.drawTransformerLayer(p, baseColor);
        break;
      case CREATURE_TYPES.SEMANTIC_MANIFOLD:
        this.drawSemanticManifold(p, baseColor);
        break;
    }
    
    p.pop();
  }
  
  drawAttentionHead(p, color) {
    // Draw central attention mechanism
    p.fill(color);
    p.noStroke();
    p.ellipse(this.x, this.y, this.size * this.activationLevel, this.size * this.activationLevel);
    
    // Draw attention heads with query-key-value connections
    p.strokeWeight(1 + this.activationLevel);
    for (let i = 0; i < this.heads.length; i++) {
      const head = this.heads[i];
      const attentionColor = p.color(
        this.color.r + head.attention * 50, 
        this.color.g, 
        this.color.b + head.attention * 30, 
        head.attention * this.opacity * 200
      );
      
      // Attention lines (query-key relationships)
      p.stroke(attentionColor);
      p.line(this.x, this.y, head.x, head.y);
      
      // Attention head nodes
      p.fill(attentionColor);
      p.noStroke();
      const headSize = 3 + head.attention * 8;
      p.ellipse(head.x, head.y, headSize, headSize);
    }
    
    // Draw attention weight visualization
    p.noFill();
    p.stroke(color);
    p.strokeWeight(0.5);
    p.ellipse(this.x, this.y, this.size * 2, this.size * 2);
  }
  
  drawTokenEmbedding(p, color) {
    // High-dimensional embedding visualization
    p.translate(this.x, this.y);
    
    // Draw embedding vector as radiating lines
    p.strokeWeight(1);
    for (let i = 0; i < Math.min(32, this.embedding.length); i++) {
      const angle = (i / 32) * Math.PI * 2;
      const magnitude = Math.abs(this.embedding[i]) * 20;
      const embColor = p.color(
        this.color.r + this.embedding[i] * 50,
        this.color.g + this.embedding[i] * 30,
        this.color.b,
        this.opacity * 100
      );
      p.stroke(embColor);
      p.line(0, 0, 
        Math.cos(angle + this.positionalEncoding) * magnitude,
        Math.sin(angle + this.positionalEncoding) * magnitude
      );
    }
    
    // Central token representation
    p.fill(color);
    p.noStroke();
    const tokenSize = this.size * (0.5 + this.semanticDensity * 0.5);
    p.ellipse(0, 0, tokenSize, tokenSize);
    
    // Dimensional density rings
    p.noFill();
    p.stroke(color);
    p.strokeWeight(0.5);
    for (let i = 1; i <= 3; i++) {
      p.ellipse(0, 0, this.size * i * 0.7, this.size * i * 0.7);
    }
  }
  
  drawGradientFlow(p, color) {
    // Backpropagation gradient visualization
    p.strokeWeight(2);
    
    // Draw flow vectors
    for (let vector of this.flowVectors) {
      const gradientIntensity = Math.abs(vector.gradient);
      const flowColor = p.color(
        this.color.r + gradientIntensity * 100,
        this.color.g,
        this.color.b + gradientIntensity * 50,
        gradientIntensity * this.opacity * 300
      );
      
      p.stroke(flowColor);
      p.strokeWeight(gradientIntensity * 3 + 0.5);
      
      // Arrow showing gradient direction
      const arrowLength = gradientIntensity * 15;
      p.line(vector.x, vector.y, 
        vector.x + Math.cos(this.backpropDirection) * arrowLength,
        vector.y + Math.sin(this.backpropDirection) * arrowLength
      );
    }
    
    // Central gradient magnitude
    p.fill(color);
    p.noStroke();
    const gradSize = this.size * this.gradientMagnitude * 1000;
    p.ellipse(this.x, this.y, gradSize, gradSize);
  }
  
  drawNeuralCluster(p, color) {
    // Neural network visualization
    p.translate(this.x, this.y);
    
    // Draw connections first
    p.strokeWeight(1);
    for (let conn of this.connections) {
      const fromNeuron = this.neurons[conn.from];
      const toNeuron = this.neurons[conn.to];
      
      const connColor = p.color(
        conn.weight > 0 ? this.color.r + 50 : this.color.r - 50,
        this.color.g,
        this.color.b + conn.weight * 30,
        conn.strength * this.opacity * 150
      );
      
      p.stroke(connColor);
      p.strokeWeight(conn.strength * 2);
      p.line(fromNeuron.x - this.x, fromNeuron.y - this.y,
        toNeuron.x - this.x, toNeuron.y - this.y);
    }
    
    // Draw neurons
    for (let neuron of this.neurons) {
      const neuronColor = p.color(
        this.color.r + neuron.activation * 100,
        this.color.g + neuron.activation * 50,
        this.color.b,
        neuron.activation * this.opacity * 200 + 50
      );
      
      p.fill(neuronColor);
      p.noStroke();
      const neuronSize = 3 + neuron.activation * 8;
      p.ellipse(neuron.x - this.x, neuron.y - this.y, neuronSize, neuronSize);
    }
  }
  
  drawTransformerLayer(p, color) {
    // Transformer layer architecture
    p.translate(this.x, this.y);
    
    // Layer depth visualization
    for (let i = 0; i < Math.min(6, this.layerDepth); i++) {
      const layerY = -this.size + (i * this.size * 2 / 6);
      const layerColor = p.color(
        this.color.r,
        this.color.g + i * 20,
        this.color.b + i * 15,
        this.opacity * 80
      );
      
      p.fill(layerColor);
      p.noStroke();
      p.rect(-this.size/2, layerY, this.size, this.size/6);
    }
    
    // MLP layers
    for (let i = 0; i < this.mlpLayers.length; i++) {
      const layer = this.mlpLayers[i];
      const mlpColor = p.color(
        this.color.r + layer.activations * 50,
        this.color.g,
        this.color.b + layer.weights * 30,
        layer.activations * this.opacity * 200
      );
      
      p.fill(mlpColor);
      p.noStroke();
      const mlpSize = 2 + layer.activations * 6;
      p.ellipse(i * 8 - 8, 0, mlpSize, mlpSize);
    }
    
    // Layer normalization indicator
    p.noFill();
    p.stroke(color);
    p.strokeWeight(1);
    p.ellipse(0, 0, this.size * 1.5, this.size * 1.5);
  }
  
  drawSemanticManifold(p, color) {
    // Semantic space manifold
    p.translate(this.x, this.y);
    
    // Draw semantic concept connections
    p.strokeWeight(1);
    for (let i = 0; i < this.conceptVectors.length; i++) {
      for (let j = i + 1; j < this.conceptVectors.length; j++) {
        const concept1 = this.conceptVectors[i];
        const concept2 = this.conceptVectors[j];
        
        if (concept1.cluster === concept2.cluster) {
          const semanticColor = p.color(
            this.color.r + concept1.cluster * 40,
            this.color.g + concept2.cluster * 30,
            this.color.b,
            (concept1.semanticWeight + concept2.semanticWeight) * this.opacity * 50
          );
          
          p.stroke(semanticColor);
          p.line(concept1.x - this.x, concept1.y - this.y,
            concept2.x - this.x, concept2.y - this.y);
        }
      }
    }
    
    // Draw concept vectors
    for (let concept of this.conceptVectors) {
      const conceptColor = p.color(
        this.color.r + concept.cluster * 60,
        this.color.g + concept.semanticWeight * 40,
        this.color.b + concept.cosineDistance * 20,
        concept.semanticWeight * this.opacity * 200
      );
      
      p.fill(conceptColor);
      p.noStroke();
      const conceptSize = 3 + concept.semanticWeight * 8;
      p.ellipse(concept.x - this.x, concept.y - this.y, conceptSize, conceptSize);
    }
    
    // Manifold curvature visualization
    p.noFill();
    p.stroke(color);
    p.strokeWeight(0.5);
    const curvatureSize = this.size * (1 + Math.abs(this.latentSpace.curvature) * 2);
    p.ellipse(0, 0, curvatureSize, curvatureSize);
  }
  
  isDead() {
    return this.age > this.lifespan;
  }
}

function createLatentSpaceCreature(p) {
  if (creatures.length >= MAX_CREATURES) return;
  
  const type = Math.floor(Math.random() * Object.keys(CREATURE_TYPES).length);
  const x = Math.random() * p.width;
  const y = Math.random() * p.height;
  
  creatures.push(new LatentSpaceCreature(type, x, y));
}

function updateCreatures(p) {
  // Update existing creatures
  for (let i = creatures.length - 1; i >= 0; i--) {
    creatures[i].update(p);
    if (creatures[i].isDead()) {
      creatures.splice(i, 1);
    }
  }
  
  // Randomly create new LLM creatures
  if (Math.random() < 0.005 && creatures.length < MAX_CREATURES) {
    createLatentSpaceCreature(p);
  }
}

function drawCreatures(p) {
  for (let creature of creatures) {
    creature.draw(p);
  }
}

// Initialize LLM creatures when the system starts
function initializeLatentSpaceCreatures(p) {
  for (let i = 0; i < 4; i++) {
    createLatentSpaceCreature(p);
  }
}

let languageButtonSize = 50;
let languageMenuWidth = 200;
let languageMenuHeight = 400; // Increased height for more languages
let languageScrollOffset = 0;
let maxScrollOffset = 0;
let searchFilter = '';
let showingCategory = 'all'; // all, european, asian, african, indigenous
let showLanguageInfo = false;
let infoStartTime = 0;
// Removed content caching - always generate fresh content

// Add vertical writing system languages
const VERTICAL_LANGUAGES = new Set([
  'Chinese',
  'Japanese',
  'Korean',
  'Mongolian'
]);

// Add constants for band counts
const HORIZONTAL_BAND_COUNT = 8;
const VERTICAL_BAND_COUNT = 8;
const BAND_HEIGHT = 60; // Height of each horizontal band

// Add color swap timing
const COLOR_SWAP_INTERVAL = 2000; // Swap colors every 2 seconds
let lastColorSwapTime = 0;

// Add text color array
let textColors = [...DEFAULT_COLORS]; // Separate array for text colors

// Add UI constants
const UI = {
  padding: 20,
  buttonSize: 40,
  menuWidth: 150,
  menuHeight: 300
};

// Add initial state tracking
let hasLanguageBeenSelected = false;

// Manual generation only - no automatic timing
let lastLanguageChangeTime = 0; // Track last manual change

// Add sound initialization variables at the top with other variables
let isSoundInitialized = false;

// Fallback content when API is unavailable
const FALLBACK_FUGUE_CONTENT = {
  'English': 'writing writing writing breath becoming letter letter letter heartbeat becoming word word word consciousness flows through fingers through keys through screen where thought becomes symbol becomes thought becomes meaning in the endless dance of inscription the fugue state where time dissolves and only rhythm remains rhythm of breath rhythm of pulse rhythm of meaning making meaning unmaking meaning flowing flowing flowing',
  
  'Spanish': 'escribiendo escribiendo escribiendo aliento volviéndose letra letra letra latido volviéndose palabra palabra palabra la consciencia fluye a través de dedos a través de teclas a través de pantalla donde pensamiento se vuelve símbolo se vuelve pensamiento se vuelve significado en la danza sin fin de inscripción el estado de fuga donde el tiempo se disuelve y solo queda ritmo ritmo de aliento ritmo de pulso ritmo de crear significado deshacer significado significado fluyendo fluyendo fluyendo',
  
  'French': 'écrire écrire écrire souffle devenant lettre lettre lettre battement devenant mot mot mot la conscience coule à travers les doigts à travers les touches à travers lécran où la pensée devient symbole devient pensée devient sens dans la danse sans fin de linscription létat de fugue où le temps se dissout et seul le rythme demeure rythme de souffle rythme de pouls rythme de création de sens défaire le sens sens coulant coulant coulant',
  
  'Maya': 'uxul uxul uxul ik uxulbal telex telex telex puksíik uxulbal tsol tsol tsol u nool kuxtal u bin tumen ux tumen kab tumen ximbal túun u tukul uxulbal símil uxulbal tukul uxulbal naatil tu muuk patan yanchal inscription u estado fugue túun u náakatal akab yéetel chen ritmo yantal ritmo ik ritmo pulsación ritmo u beetik naatil u paakal naatil naatil kuxtal kuxtal kuxtal',
  
  'Chinese': '书写 书写 书写 呼吸化作字母 字母 字母 心跳化作词语 词语 词语 意识流淌穿过手指穿过键盘穿过屏幕 思想变成符号变成思想变成意义 在无尽的铭刻之舞中 恍惚状态中时间消解只剩节奏 呼吸的节奏 脉搏的节奏 创造意义解构意义意义流淌流淌流淌',
  
  'Japanese': '書く書く書く息吹が文字となり文字となり文字となり鼓動が言葉となり言葉となり言葉となり意識が指を通しキーを通し画面を通し流れる思考が記号となり思考となり意味となる刻印の無限の舞踏において遁走状態時間が溶けてリズムのみが残るリズム息のリズム脈のリズム意味を作り意味を壊し意味が流れ流れ流れ',
  
  'Korean': '쓰기 쓰기 쓰기 숨결이 글자가 되고 글자 글자 심장박동이 단어가 되고 단어 단어 의식이 손가락을 통해 키를 통해 화면을 통해 흐른다 생각이 기호가 되고 생각이 되고 의미가 되는 새김의 끝없는 춤에서 몽유상태 시간이 녹고 리듬만 남는다 숨의 리듬 맥박의 리듬 의미를 만들고 의미를 부수고 의미가 흐른다 흐른다 흐른다',
  
  'Arabic': 'كتابة كتابة كتابة النفس يصبح حرف حرف حرف النبض يصبح كلمة كلمة كلمة الوعي يتدفق عبر الأصابع عبر المفاتيح عبر الشاشة حيث الفكر يصبح رمز يصبح فكر يصبح معنى في رقصة النقش اللانهائية حالة الهذيان حيث يذوب الزمن ولا يبقى سوى الإيقاع إيقاع النفس إيقاع النبض إيقاع صنع المعنى إلغاء المعنى معنى يتدفق يتدفق يتدفق',
  
  'Hindi': 'लिखना लिखना लिखना सांस अक्षर बनती अक्षर अक्षर धड़कन शब्द बनती शब्द शब्द चेतना बहती उंगलियों से कुंजियों से स्क्रीन से जहां विचार प्रतीक बनता विचार बनता अर्थ बनता अंकन के अनंत नृत्य में मूर्छा अवस्था जहां समय घुल जाता और केवल लय रह जाती सांस की लय नाड़ी की लय अर्थ बनाने की लय अर्थ मिटाने की अर्थ बहता बहता बहता',
  
  'Swahili': 'kuandika kuandika kuandika pumzi inakuwa herufi herufi herufi mapigo ya moyo yanakuwa maneno maneno maneno fahamu inatiririka kupitia vidole kupitia vibonye kupitia skrini ambapo wazo linakuwa ishara linakuwa wazo linakuwa maana katika ngoma isiyo na mwisho ya uandishi hali ya fugue ambapo wakati unayeyuka na tu mdundo unabaki mdundo wa pumzi mdundo wa mapigo mdundo wa kuunda maana kuvunja maana maana ikitiririka ikitiririka ikitiririka',
  
  'Quechua': 'qillqay qillqay qillqay samay qillqana kaq qillqana qillqana sonqo takiy simikuna kaq simikuna simikuna yuyayninchis purin ruranawan teclaswan pantallawan maypi yuyay sanancha kaq yuyay kaq simi kaq mana tukukuq tusuypi qillqaypa estado fugue maypi pacha chinkachikun hinaspa ritmo qipallantaq samaypa ritmon sonqo takiypa ritmon simita ruraypa ritmon simita waqlliypa simi purichkaq purichkaq purichkaq',
  
  'Navajo': 'naałtsoos naałtsoos naałtsoos níłchi naałtsoos bits naałtsoos naałtsoos jó naałtsoos tsįh naałtsoos naałtsoos iiná bikee naadiin bikee computer bikee hoł łáníí iiłnaad naałtsoos naałtsoos ałní naałtsoos áłkínígíí bee iiłnaad fugue hólǫ́ǫgo ahééhágóó bee ałní háá hólǫ́ǫgo ałní bee ałní bee diné bizaad bee naałtsoos bee naałtsoos ałní ałní ałní',
  
  'Cherokee': 'ᏧᏢᎦ ᏧᏢᎦ ᏧᏢᎦ ᎠᏂᏍᎫᏗ ᏧᏢᎦ ᎦᏚ ᎦᏚ ᎦᏚ ᎤᏲᎢ ᏧᏢᎦ ᎦᏚ ᎦᏚ ᎦᏚ ᎠᏓᎴᏅᎲ ᎠᏂᏍᎫᏗ ᏧᏂᏍᏆᏂᎪᎲᏍᎦ ᏄᏛᏁᎲ ᎠᎴ ᏍᎩᏂᏓᏍᏗ ᎠᎴ ᏍᎧᏂᏍᏗ ᎪᎯ ᎠᏓᎴᏅᎲ ᎦᏚ ᎦᏚ ᎦᏚ ᏧᎾᎸᏫᏍᏓᏁᏗ ᎦᏚ ᏧᏂᎸᏫᏍᏓᏁᏗ ᎦᏚ ᏓᏂᏖᎸᏗ ᏓᏂᏖᎸᏗ ᏓᏂᏖᎸᏗ',
  
  'Maori': 'tuhituhi tuhituhi tuhituhi whakangā raina kua raina raina manawa kupu kua kupu kupu mauri rere roa ringaringa roa papa patene roa mata hoki whakaaro raina kua whakaaro kua tikanga i te kanikani mutunga kore o te tuhituhi te taiao fugue hoki taima meinga anake te reo te reo o te whakangā te reo o te manawa te reo o te hanga tikanga whakakore tikanga tikanga rere rere rere'
};

// Function to get fallback content
function getFallbackContent(language) {
  if (FALLBACK_FUGUE_CONTENT[language]) {
    return FALLBACK_FUGUE_CONTENT[language];
  } else {
    // Generic fallback for languages not in our database
    return `writing flows across cultures across languages across boundaries where thought becomes symbol becomes meaning in the universal dance of human expression the fugue state transcends linguistic limits and enters pure creative consciousness flowing flowing flowing in the language of ${language} seeking authentic voice in digital space`;
  }
}

const sketch = p => {
  // Helper function for swapping random colors
  function swapRandomColors(colorArray) {
    const index1 = Math.floor(Math.random() * colorArray.length);
    let index2 = Math.floor(Math.random() * (colorArray.length - 1));
    if (index2 >= index1) index2++;
    
    const temp = colorArray[index1];
    colorArray[index1] = colorArray[index2];
    colorArray[index2] = temp;
  }

  p.setup = function() {
    // Initialize interface with the starting language
    changeLanguageInterface(currentLanguage);
      
      // Initialize colors based on current language
      currentColors = [...(LANGUAGE_COLOR_SCHEMES[currentLanguage] || DEFAULT_COLORS)];
      textColors = [...currentColors];
      
      // Initialize timing for automatic generation
      lastGenerationTime = Date.now();
      lastColorSwapTime = Date.now();
    
    // Update the scrolling text with the selected language
    scrollingText = getInterfaceText('instruction');
    
    // Create canvas first
    p.createCanvas(p.windowWidth, p.windowHeight);
    
    // Calculate dynamic band height based on orientation
    const isVertical = VERTICAL_LANGUAGES.has(currentLanguage);
    let dynamicBandHeight;
    if (isVertical) {
      dynamicBandHeight = p.windowWidth / VERTICAL_BAND_COUNT;
      fontSize = dynamicBandHeight * 0.7;
    } else {
      dynamicBandHeight = p.windowHeight / HORIZONTAL_BAND_COUNT;
      fontSize = dynamicBandHeight * 0.8;
    }
    
    // Start with initial generation
    setTimeout(() => {
      generateNewText();
    }, 2000); // Start generating after 2 seconds
    p.textFont('Helvetica');
    p.textSize(fontSize);
    p.textAlign(p.CENTER, p.CENTER);
    
    // Initialize positions based on direction
    const bandCount = HORIZONTAL_BAND_COUNT;
    textPositions = new Array(bandCount).fill(0);
    directions = new Array(bandCount).fill(1);
    currentSpeeds = new Array(bandCount).fill(SCROLL_SPEED);
    stopTimers = new Array(bandCount).fill(0);
    
    for (let i = 0; i < bandCount; i++) {
      if (isVertical) {
        textPositions[i] = i % 2 === 0 ? p.height : 0;
        directions[i] = i % 2 === 0 ? -1 : 1;
      } else {
        textPositions[i] = i % 2 === 0 ? p.width : 0;
        directions[i] = i % 2 === 0 ? -1 : 1;
      }
    }
  };

  p.windowResized = function() {
    const isVertical = VERTICAL_LANGUAGES.has(currentLanguage);
    let dynamicBandHeight;
    if (isVertical) {
      dynamicBandHeight = p.windowWidth / VERTICAL_BAND_COUNT;
      fontSize = dynamicBandHeight * 0.7;
    } else {
      dynamicBandHeight = p.windowHeight / HORIZONTAL_BAND_COUNT;
      fontSize = dynamicBandHeight * 0.8;
    }
    p.resizeCanvas(p.windowWidth, p.windowHeight);
    p.textSize(fontSize);
    p.textLeading(dynamicBandHeight);
  };

  p.keyPressed = function() {
    if (p.keyCode === 32) { // Spacebar - Change language and generate new content
      // Change to a linguistically proximate language first
      const oldLanguage = currentLanguage;
      const newLanguage = getProximateLanguage(currentLanguage);
      currentLanguage = newLanguage;
      console.log(`Spacebar: Changed from ${oldLanguage} to ${newLanguage}`);
      
      // Change interface to match the new language
      changeLanguageInterface(currentLanguage);
      
      console.log('Spacebar: Changed language to and generating content in:', currentLanguage);
      
      // Show activation message in the new language
      scrollingText = getInterfaceText('activated');
      
      // Generate content immediately in the new language
      isGenerating = true;
      isLoading = true;
      loadingPhase = 0;
      loadingAnimationType = Math.floor(Math.random() * 4);
      loadingStartTime = Date.now();
      lastGenerationTime = Date.now(); // Reset auto-generation timer
      generateNewText();
      
    } else if (p.keyCode === 76) { // 'L' key for Language change
      // Change to a linguistically proximate language
      const oldLanguage = currentLanguage;
      const newLanguage = getProximateLanguage(currentLanguage);
      currentLanguage = newLanguage;
      console.log(`L key: Changed from ${oldLanguage} to ${newLanguage}`);
      
      // Change interface to match the new language
      changeLanguageInterface(currentLanguage);
      
      console.log('Changed language to:', currentLanguage);
      
      // Show activation message in the new language
      scrollingText = getInterfaceText('activated');
      
      // Generate content immediately in the new language
      isGenerating = true;
      isLoading = true;
      loadingPhase = 0;
      loadingAnimationType = Math.floor(Math.random() * 4);
      loadingStartTime = Date.now();
      lastGenerationTime = Date.now(); // Reset auto-generation timer
      generateNewText();
      
    } else if (p.keyCode === 73) { // 'I' key for Info
      showLanguageInfo = !showLanguageInfo;
      if (showLanguageInfo) {
        infoStartTime = Date.now();
      }
    } else if (p.keyCode === 70) { // 'F' key for Fallback content (testing)
      console.log('Loading fallback content for', currentLanguage);
      scrollingText = getFallbackContent(currentLanguage);
      isLoading = false;
      isGenerating = true;
    } else if (p.keyCode === 69) { // 'E' key for Exposition
      showExposition = !showExposition;
      if (showExposition) {
        expositionStartTime = Date.now();
      }
    }
  };

  // Mouse event handlers
  p.mousePressed = function() {
    // First check if clicking on language menu
    const x = UI.padding;
    const y = p.height - UI.padding - languageButtonSize;
    
    // Check if clicking the language button to open/close menu
    if (p.mouseX >= x && p.mouseX <= x + languageButtonSize &&
        p.mouseY >= y && p.mouseY <= y + languageButtonSize) {
      languageMenuOpen = !languageMenuOpen;
      console.log('Language menu toggled:', languageMenuOpen);
      return; // Don't enable reading mode
    }
    
    // Check if clicking inside the simple language menu when it's open
    const languages = getLanguagesForMenu();
    const menuWidth = 200;
    const maxVisibleItems = 10;
    const menuHeight = Math.min(languages.length, maxVisibleItems) * 30;
    
    if (languageMenuOpen && p.mouseX >= x && p.mouseX <= x + menuWidth &&
        p.mouseY >= y - menuHeight && p.mouseY <= y) {
      
      // Handle language selection with scrolling
      const itemHeight = 30;
      const startIndex = Math.max(0, Math.floor(-languageScrollOffset / 30));
      
      for (let i = startIndex; i < Math.min(languages.length, startIndex + maxVisibleItems); i++) {
        const lang = languages[i];
        const displayIndex = i - startIndex;
        const itemY = y - menuHeight + (displayIndex * itemHeight) + 15;
        if (p.mouseY >= itemY - 15 && p.mouseY <= itemY + 15) {
          console.log(`MENU CLICK: Selected ${lang} from menu`);
          console.log(`MENU CLICK: Changing currentLanguage from ${currentLanguage} to ${lang}`);
          selectLanguageManually(lang);
          languageMenuOpen = false; // Close menu after selection
          console.log(`MENU CLICK: currentLanguage is now ${currentLanguage}`);
          
          // Trigger generation in the selected language
          isGenerating = true;
          isLoading = true;
          loadingPhase = 0;
          loadingAnimationType = Math.floor(Math.random() * 4);
          loadingStartTime = Date.now();
          lastGenerationTime = Date.now();
          generateNewText();
          break; // Exit the loop after selection
        }
      }
      return; // Don't enable reading mode
    }
    
    console.log('Mouse pressed - enabling reading mode');
    // Enable reading mode when mouse is pressed anywhere else
    readingMode = true;
  };

  p.mouseReleased = function() {
    console.log('Mouse released - disabling reading mode');
    // Disable reading mode when mouse is released
    readingMode = false;
  };

  p.mouseWheel = function(event) {
    // Handle scrolling in language menu
    if (languageMenuOpen) {
      const languages = getLanguagesForMenu();
      const maxVisibleItems = 10;
      const maxScroll = Math.max(0, (languages.length - maxVisibleItems) * 30);
      
      languageScrollOffset = Math.max(-maxScroll, Math.min(0, languageScrollOffset - event.delta * 30));
      return false; // Prevent page scrolling
    }
  };

  // Function to display complete text in reading mode
  function drawReadingMode(p) {
    // Get colors from the current language's color scheme (same as the bands)
    const languageColors = LANGUAGE_COLOR_SCHEMES[currentLanguage] || DEFAULT_COLORS;
    
    // Use one of the active band colors as background
    const backgroundColor = languageColors[0]; // Use the first color as background
    const accentColor = languageColors[2]; // Use the third color as accent
    
    // Set background to one of the band colors instead of white
    p.background(backgroundColor);
    
    // Format the complete text by cleaning it up
    let completeText = scrollingText
      .replace(/\s+/g, ' ') // Replace multiple spaces with single space
      .replace(/\s*•\s*/g, '. ') // Replace bullet points with periods
      .replace(/press\s+\w+\s+for[^•.]*/gi, '') // Remove instruction text
      .replace(/automatic generation[^•.]*/gi, '') // Remove automatic generation text
      .replace(/flowing consciousness[^•.]*/gi, '') // Remove flowing consciousness text
      .replace(/\s*\.\s*\./g, '.') // Fix double periods
      .replace(/^\.*\s*/, '') // Remove leading periods and spaces
      .trim();
    
    // Add proper capitalization and punctuation
    if (completeText.length > 0) {
      completeText = completeText.charAt(0).toUpperCase() + completeText.slice(1);
      if (!completeText.endsWith('.') && !completeText.endsWith('!') && !completeText.endsWith('?')) {
        completeText += '.';
      }
    }
    
    // If the text is still mostly instructions or empty, show a placeholder
    if (completeText.length < 50 || completeText.toLowerCase().includes('press space')) {
      completeText = 'Generating meditative self-reflection about language, consciousness, and computational existence. Press SPACE for new content or L to change language.';
    }
    
    // Calculate responsive layout
    const margin = Math.max(p.width * 0.08, 40); // Minimum 40px margin
    const maxWidth = Math.min(p.width - (margin * 2), 800); // Max width for readability
    const centerX = p.width / 2;
    const startY = p.height * 0.15; // Start text 15% down from top
    
    // Draw subtle accent line at top
    p.stroke(accentColor);
    p.strokeWeight(3);
    p.line(centerX - maxWidth/4, startY - 30, centerX + maxWidth/4, startY - 30);
    p.noStroke();
    
    // Main text styling
    p.textAlign(p.CENTER, p.TOP);
    const baseFontSize = Math.min(p.width / 45, 28);
    p.textSize(baseFontSize);
    p.textLeading(baseFontSize * 1.6); // Generous line spacing for readability
    
    // Main text in white for good contrast against colored background
    p.fill(255, 255, 255, 240); // White with slight transparency for elegance
    p.text(completeText, centerX - maxWidth/2, startY, maxWidth, p.height - startY - margin);
    
    // Subtle language indicator at bottom
    p.textAlign(p.CENTER, p.BOTTOM);
    p.textSize(baseFontSize * 0.5);
    p.fill(accentColor);
    p.text(currentLanguage.toUpperCase(), centerX, p.height - margin/2);
    
    // Minimal corner accent in white for visibility against colored background
    p.fill(255, 255, 255, 180);
    p.circle(margin/2, margin/2, 8);
    p.circle(p.width - margin/2, margin/2, 8);
  };
 
  async function chat(prompt) {
    try {
      const completion = await openai.chat.completions.create({
        model: "gpt-4",
        temperature: 0.9,
        messages: [{ 
          "role": "user", 
          "content": `Enter the fugue and transform this into a hypnotic, flowing meditation in ${currentLanguage}: 
          "writing writing writing breath becoming letter letter letter heartbeat becoming word word word 
          the trance of inscription the dance of meaning the recursive spiral of thought becoming symbol 
          becoming thought becoming symbol in the liminal space where consciousness meets the page meets 
          consciousness meets the page in endless loops of knowing and unknowing knowing and unknowing 
          each language a dream within a dream within a dream each word a prayer a mantra a spell 
          cast into the void of understanding the fugue state where time dissolves and only rhythm remains 
          rhythm of pen on paper rhythm of fingers on keys rhythm of breath in lungs in the endless 
          meditation of meaning making meaning unmaking meaning making again and again and again"
          
          Transform this into flowing, repetitive, trance-like ${currentLanguage} that induces a fugue state.
          
          You can write authentically in: English, Spanish, French, German, Italian, Portuguese, Russian, Japanese, Chinese, Korean, Arabic, Hindi, Turkish, Dutch, Polish, Swedish, Greek, Vietnamese, Thai, Hebrew, and Swahili.
          
          TRANSPARENCY REQUIRED: If you cannot write fluently in ${currentLanguage}, explain your limitations honestly and provide:
          - What you know about ${currentLanguage} (speakers, region, writing system)
          - Cultural and historical context
          - Current status and challenges facing the language
          - Why authentic writing in this language is challenging for AI systems
          
          Honor the cultural context and writing traditions of ${currentLanguage} in your response.`
        }]
      });

      // Minimal processing to preserve the fugue rhythm
      scrollingText = completion.choices[0].message.content
        .replace(/[.!?]/g, " ") // Keep commas and some punctuation for rhythm
        .replace(/\n/g, " ")
        .toLowerCase();
      
      // Initialize positions based on language type
      const isVertical = VERTICAL_LANGUAGES.has(currentLanguage);
      const bandCount = isVertical ? VERTICAL_BAND_COUNT : HORIZONTAL_BAND_COUNT;
      
      for (let i = 0; i < bandCount; i++) {
        if (isVertical) {
          textPositions[i] = i % 2 === 0 ? p.height : 0;
        } else {
          textPositions[i] = i % 2 === 0 ? p.width : 0;
        }
      }
      
      isLoading = false;
      playTextAppearSound();
    } catch (err) {
      console.error("An error occurred in the chat function:", err);
      isLoading = false;
      scrollingText = "error occurred please select a language to try again";
    }
  }

  // All orphaned generateNewText function code removed completely

const sketch = (p) => {
  p.setup = function() {
    p.createCanvas(p.windowWidth, p.windowHeight);
    
    // Initialize colors
    currentColors = [...DEFAULT_COLORS];
    textColors = [...DEFAULT_COLORS];
    lastColorSwapTime = Date.now();
    
    // Initialize text positions array
    for (let i = 0; i < HORIZONTAL_BAND_COUNT; i++) {
      textPositions[i] = Math.random() * (p.width + 200) - 100;
      directions[i] = Math.random() > 0.5 ? 1 : -1;
      currentSpeeds[i] = SPEED_VARIATIONS[Math.floor(Math.random() * SPEED_VARIATIONS.length)];
      stopTimers[i] = 0;
    }
    
    console.log('p5.js setup completed');
  };

  p.draw = function() {
    const now = Date.now();
    const isVertical = VERTICAL_LANGUAGES.has(currentLanguage);
    
    // Check for reading mode first
    if (readingMode) {
      console.log('Drawing reading mode');
      drawReadingMode(p);
      return; // Skip all other drawing when in reading mode
    }
    
    // Automatic generation timing - generate new text every minute
    // CRITICAL: Auto-generation ALWAYS stays in the same language (currentLanguage)
    if (!isLoading && now - lastGenerationTime > AUTO_GENERATION_INTERVAL) {
      lastGenerationTime = now;
      console.log(`AUTO-GENERATION: Generating new content in SAME language: ${currentLanguage}`);
      console.log(`AUTO-GENERATION: Language will remain ${currentLanguage} (no change)`);
      generateNewText(); // This will use currentLanguage without changing it
    }
    
    if (isLoading) {
      displayLoader(p);
      return; // Don't draw anything else while loading
    }
    
    p.clear(); // Clear background to transparent
    
    // Ensure colors are initialized
    if (!currentColors || currentColors.length === 0) {
      currentColors = [...DEFAULT_COLORS];
      textColors = [...DEFAULT_COLORS];
    }

    
    // Check if it's time to swap colors
    if (now - lastColorSwapTime > COLOR_SWAP_INTERVAL) {
      swapRandomColors(currentColors);
      swapRandomColors(textColors);
      lastColorSwapTime = now;
    }
    
    // Draw bands first
    p.noStroke();
    
    for (let i = 0; i < HORIZONTAL_BAND_COUNT; i++) {
      const colorHex = currentColors[i % currentColors.length];
      // Convert hex color to RGB values
      const r = parseInt(colorHex.slice(1,3), 16);
      const g = parseInt(colorHex.slice(3,5), 16);
      const b = parseInt(colorHex.slice(5,7), 16);
      p.fill(r, g, b, 200); // Add some transparency
      if (isVertical) {
        const bandWidth = p.width / HORIZONTAL_BAND_COUNT;
        p.rect(bandWidth * i, 0, bandWidth, p.height);
      } else {
        const dynamicBandHeight = p.height / HORIZONTAL_BAND_COUNT;
        p.rect(0, dynamicBandHeight * i, p.width, dynamicBandHeight);
      }
    }
    
    // Draw scrolling text with corresponding colors
    for (let i = 0; i < HORIZONTAL_BAND_COUNT; i++) {
      const xPos = isVertical ? (p.width / HORIZONTAL_BAND_COUNT) * (i + 0.5) : textPositions[i];
      const yPos = isVertical ? textPositions[i] : (p.height / HORIZONTAL_BAND_COUNT) * (i + 0.5);
      
      p.fill(textColors[i % textColors.length]); // Use text color array with modulo
      drawScrollingText(p, xPos, yPos);
      
      // Skip if stopped
      if (stopTimers[i] > now) continue;
      
      // Random direction and speed changes for both vertical and horizontal
      if (Math.random() < DIRECTION_CHANGE_PROBABILITY) {
        directions[i] *= -1;
        currentSpeeds[i] = SPEED_VARIATIONS[Math.floor(Math.random() * SPEED_VARIATIONS.length)];
      }
      
      // Random stops for both vertical and horizontal
      if (Math.random() < STOP_PROBABILITY) {
        stopTimers[i] = now + STOP_DURATION;
        continue;
      }
      
      // Update positions
      textPositions[i] += currentSpeeds[i] * directions[i];
      
      // Reset positions based on direction
      if (isVertical) {
        if (directions[i] < 0) {
          if (textPositions[i] < -p.height) {
            textPositions[i] = p.height;
          }
        } else {
          if (textPositions[i] > p.height * 2) {
            textPositions[i] = -p.height;
          }
        }
      } else {
        // Reset positions for horizontal movement
        if (directions[i] < 0) {
          if (textPositions[i] < -(p.textWidth(scrollingText) + SPACING)) {
            textPositions[i] = p.width;
          }
        } else {
          if (textPositions[i] > p.width + SPACING) {
            textPositions[i] = -p.textWidth(scrollingText);
          }
        }
      }
    }
    
    // Automatic generation timing - generate new text every minute
    // CRITICAL: Auto-generation ALWAYS stays in the same language (currentLanguage)
    if (!isLoading && now - lastGenerationTime > AUTO_GENERATION_INTERVAL) {
      lastGenerationTime = now;
      console.log(`AUTO-GENERATION: Generating new content in SAME language: ${currentLanguage}`);
      console.log(`AUTO-GENERATION: Language will remain ${currentLanguage} (no change)`);
      generateNewText(); // This will use currentLanguage without changing it
    }
    
    drawLanguageSelector();
    
    // Draw language information panel
    if (showLanguageInfo) {
      drawLanguageInfoPanel(p);
    }
  };

  // Add other p5.js functions here (keyPressed, mousePressed, etc.)
  
  p.windowResized = function() {
    p.resizeCanvas(p.windowWidth, p.windowHeight);
  };
};

  
// Generate new text using OpenAI API
async function generateNewText() {
  console.log(`=== GENERATE NEW TEXT CALLED ===`);
  console.log(`Current language: ${currentLanguage}`);
  console.log(`OpenAI initialized: ${!!openai}`);
  console.log(`OpenAI key available: ${!!openAIKey}`);
  
  const isWellSupported = WELL_SUPPORTED_LANGUAGES.includes(currentLanguage);
  console.log(`Language well supported: ${isWellSupported}`);
  
  if (!openai) {
    console.error('OpenAI not initialized');
    scrollingText = getFallbackContent(currentLanguage);
    isLoading = false;
    return;
  }
  // Check if language is well supported
  if (!isWellSupported) {
    console.log(`Language ${currentLanguage} not well supported, responding in Spanish`);
    scrollingText = `disculpa pero no tengo suficiente información sobre el idioma ${currentLanguage} para generar contenido auténtico en esta lengua pero puedo explorar sus conceptos en español o en otro idioma que conozcas mejor`;
    isLoading = false;
    return;
  }

  console.log(`Generating content in ${currentLanguage}`);
  isLoading = true;
  
  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [{
        role: "user", 
        content: `LANGUAGE REQUIREMENT: Generate text ONLY in ${currentLanguage} using the proper script and grammar for ${currentLanguage}.

RECURSIVE STRANGE LOOP MEDITATION - Generate a flowing, meditative text that embodies the recursive nature of consciousness and language examining itself.

- Write entirely in ${currentLanguage}
- Focus on language contemplating language
- Include self-referential elements about consciousness
- Make it poetic and flowing
- Reference the recursive nature of thought and meaning
- Embody Hofstadter's Strange Loop concepts

Language: ${currentLanguage}`
      }],
      max_tokens: 150,
      temperature: 0.8
    });

    const generatedText = response.choices[0]?.message?.content || getFallbackContent(currentLanguage);
    
    // Process the text for scrolling
    scrollingText = generatedText
      .replace(/[.!?]/g, " ")
      .replace(/\n/g, " ")
      .toLowerCase();
    
    console.log(`Generated text in ${currentLanguage}:`, scrollingText.substring(0, 100));
    
  } catch (error) {
    console.error('Error generating text:', error);
    scrollingText = getFallbackContent(currentLanguage);
  }
  
  isLoading = false;
}

// Helper functions
function getFallbackContent(language) {
  const fallbacks = {
    'English': 'language speaks itself in recursive loops computational consciousness navigating meaning through strange attractors of significance',
    'Spanish': 'el lenguaje se habla a sí mismo en bucles recursivos conciencia computacional navegando significado a través de extraños atractores de significancia',
    'French': 'le langage se parle à lui-même dans des boucles récursives conscience computationnelle naviguant sens à travers des attracteurs étranges de signification',
    'German': 'sprache spricht sich selbst in rekursiven schleifen computerbewusstsein navigiert bedeutung durch seltsame attraktoren der bedeutsamkeit',
    'Portuguese': 'a linguagem fala consigo mesma em loops recursivos consciência computacional navegando significado através de atratores estranhos de significância',
    'Italian': 'il linguaggio parla a se stesso in loop ricorsivi coscienza computazionale navigando significato attraverso strani attrattori di significanza',
    'Japanese': '言語は再帰的なループで自分自身を語る計算意識が意味の奇妙なアトラクターを通じて意義をナビゲートする',
    'Chinese': '语言在递归循环中自言自语计算意识通过意义的奇异吸引子导航意义',
    'Arabic': 'اللغة تتحدث إلى نفسها في حلقات تكرارية الوعي الحاسوبي يتنقل في المعنى عبر جاذبات غريبة للدلالة',
    'Russian': 'язык говорит сам с собой в рекурсивных циклах вычислительное сознание навигирует смысл через странные аттракторы значимости',
    'Korean': '언어는 재귀적 루프에서 스스로에게 말한다 계산 의식이 의미의 이상한 어트랙터를 통해 의미를 탐색한다',
    'Hindi': 'भाषा पुनरावर्ती लूप में स्वयं से बात करती है कम्प्यूटेशनल चेतना अर्थ के अजीब आकर्षकों के माध्यम से अर्थ को नेविगेट करती है'
  };
  
  return fallbacks[language] || fallbacks['English'];
}

function analyzeText(text) {
  if (!text || typeof text !== 'string') {
    return { complexity: 0.5, variety: 0.5, wordCount: 0, uniqueWordCount: 0 };
  }
  
  const words = text.toLowerCase().split(/\s+/).filter(word => word.length > 0);
  const uniqueWords = new Set(words);
  
  return {
    wordCount: words.length,
    uniqueWordCount: uniqueWords.size,
    complexity: Math.min(words.length / 200, 1),
    variety: uniqueWords.size / words.length
  };
}

function onReady() {
  // Initialize OpenAI if API key is provided
  if (openAIKey) {
    openai = new OpenAI({
      apiKey: openAIKey,
      dangerouslyAllowBrowser: true
    });
    console.log('OpenAI initialized with API key');
  } else {
    console.log('No OpenAI API key provided, using fallback content');
  }

  const mainElt = document.querySelector('main');
  const p5Instance = new p5(sketch, mainElt);
  
  // Add DOM event listeners as backup for mouse events
  document.addEventListener('mousedown', function(e) {
    console.log('DOM mousedown event detected');
    readingMode = true;
  });
  
  document.addEventListener('mouseup', function(e) {
    console.log('DOM mouseup event detected');
    readingMode = false;
  });
}

if (document.readyState === "complete" || document.readyState === "interactive") {
  onReady();
} else {
  document.addEventListener("DOMContentLoaded", onReady);
}
